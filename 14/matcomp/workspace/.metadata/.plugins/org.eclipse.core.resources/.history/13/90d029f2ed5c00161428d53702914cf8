
public class Jacobi {
	public static float E = 0.00001f;//Precisão
	
	
	public static boolean transformToDominant(int r, boolean[] V, int[] R)
    {
        int n = M.length;
        if (r == M.length) {
            double[][] T = new double[n][n+1];
            for (int i = 0; i < R.length; i++) {
                for (int j = 0; j < n + 1; j++)
                    T[i][j] = M[R[i]][j];
            }
 
            M = T;
 
            return true;
        }
 
        for (int i = 0; i < n; i++) {
            if (V[i]) continue;
 
            double sum = 0;
 
            for (int j = 0; j < n; j++)
                sum += Math.abs(M[i][j]);
 
            if (2 * Math.abs(M[i][r]) > sum) { // diagonally dominant?
                V[i] = true;
                R[r] = i;
 
                if (transformToDominant(r + 1, V, R))
                    return true;
 
                V[i] = false;
            }
        }
 
        return false;
    }
 
    /**
     * Returns true if is possible to transform M(data member) to a diagonally
     * dominant matrix, false otherwise.
     */
    public static boolean makeDominant()
    {
        boolean[] visited = new boolean[M.length];
        int[] rows = new int[M.length];
 
        Arrays.fill(visited, false);
 
        return transformToDominant(0, visited, rows);
    }
	
	public static boolean shouldStop(float[] x, float[] x0) {
//			x(k) − x(k-1)
		for (int i = 0; i < x.length; i++) {
			float sub = x[i] - x0[i];
			if (Math.abs(sub) < E) {
				return false;
			}
		}
		return true;
	}

	public static void jacobi(float[][] A, float[] b) {
		int i, j, k;
		boolean _return_ = true;
		float sum = 0;
		int max = 1000;
		float[] x = new float[A.length];
		float[] x0 = new float[A.length];
		
//		if (diagonallyDominant(A)){
		for (k = 0; k < max; k++) {
			sum = 0;
			for (i = 0; i < A.length; i++) {
				for (j = 0; j < A.length; j++) {
					if(i != j){
						sum += (A[i][j] * x0[j]);
					}
				}
				x[i] = (b[i] - sum)/A[i][j];				
			}
			
			if(shouldStop(x, x0)) {
				
			}
			
			// coping
			for (i = 0; i < x0.length; i++) {
				x0[i] = x[i]; 
			}
		}
		if (k >= max) {
			_return_ = false;
		}
		else {
			_return_ = true;
		}
//		}
	}
	
	public static void main(String[] args) {
		// TODO Auto-generated method stub

	}

}
