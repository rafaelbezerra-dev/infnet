import java.util.Arrays;

public class Jacobi {
	public static float E = 0.00001f;//Precisão
	
	
	public static boolean transformToDominant(float[][] M, int r, boolean[] V, int[] R)
    {
        int n = M.length;
        if (r == M.length) {
            float[][] T = new float[n][n+1];
            for (int i = 0; i < R.length; i++) {
                for (int j = 0; j < n + 1; j++)
                    T[i][j] = M[R[i]][j];
            }
 
            M = T;
 
            return true;
        }
 
        for (int i = 0; i < n; i++) {
            if (V[i]) continue;
 
            double sum = 0;
 
            for (int j = 0; j < n; j++)
                sum += Math.abs(M[i][j]);
 
            if (2 * Math.abs(M[i][r]) > sum) { // diagonally dominant?
                V[i] = true;
                R[r] = i;
 
                if (transformToDominant(M, r + 1, V, R))
                    return true;
 
                V[i] = false;
            }
        }
 
        return false;
    }
 
    /**
     * Returns true if is possible to transform M(data member) to a diagonally
     * dominant matrix, false otherwise.
     */
    public static boolean makeDominant(float[][] A, float[] b)
    {
    	int n = A.length;
    	float[][] M = new float[n][n+1];
    	for (int i = 0; i < b.length; i++) {
			M[i][n] = b[i]; 
		}
    	
        boolean[] visited = new boolean[n];
        int[] rows = new int[n];
 
        Arrays.fill(visited, false);
 
        return transformToDominant(M, 0, visited, rows);
    }
	
	public static boolean shouldStop(float[] x, float[] x0) {
//			x(k) − x(k-1)
		for (int i = 0; i < x.length; i++) {
			float sub = x[i] - x0[i];
			if (Math.abs(sub) < E) {
				return false;
			}
		}
		return true;
	}

	public static void jacobi(float[][] A, float[] b) {
		int i, j, k;
		boolean _return_ = true;
		float sum = 0;
		int max = 100; //1000;
		float[] x = new float[A.length];
		float[] x0 = new float[A.length];
		
		if (!makeDominant(A, b)){
			for (k = 0; k < max; k++) {
				sum = 0;
				for (i = 0; i < A.length; i++) {
					for (j = 0; j < A.length; j++) {
						if(i != j){
							sum += - (A[i][j] * x0[j]);
						}
					}
					x[i] = (b[i] + sum)/A[i][i];				
				}
				
	//			if(shouldStop(x, x0)) {
	//				break;
	//			}
				
				// coping
				for (i = 0; i < x0.length; i++) {
					x0[i] = x[i]; 
				}
				
				System.out.print("x = ");
				for (i = 0; i < x.length; i++) {
					System.out.print(x[i] + ",  "); 
				}
				System.out.println("");
			}
			
	//		System.out.print("x = ");
	//		for (i = 0; i < x.length; i++) {
	//			System.out.print(x[i] + ",  "); 
	//		}
			
			if (k >= max) {
				_return_ = false;
			}
			else {
				_return_ = true;
			}
		}
		else{
            System.out.println("The system isn't diagonally dominant: " + 
                    "The method cannot guarantee convergence.");
        }
	}
	
	public static void main(String[] args) {
		// TODO Auto-generated method stub
//		float[][] A = { 
//				{  4, -1, -1 }, 
//				{ -2,  6,  1 }, 
//				{ -1,  1,  7 } 
//		};
//		float[] b = { 3, 9, -6 };
		
		float[][] A = { 
				{ 70,	1,	0 },
				{ 60,	-1,	1 },
				{ 40,	0,	-1 }
		};
		float[] b = { 636, 518, 307 };
		jacobi(A, b);
	}

}
